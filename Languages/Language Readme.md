This is my attempt at a comprehensive LeetCode language comparison
document by covering aspects that are important for problem-solving,
efficiency, and readability. Here's a detailed breakdown of my set of
categories for each language:

---

### 1. Language Basics

 Type System: Static vs dynamic typing, strong vs weak typing.
 Paradigm: Procedural, object-oriented, functional, or
multi-paradigm.  Syntax Overview: Key differences for
declaring variables, functions, classes, loops, conditionals.

---

### 2. Data Structures

 Built-in Data Structures: Lists/arrays, sets,
maps/dictionaries, tuples, stacks, queues, heaps.  Custom
Implementations: How easy it is to implement trees, linked lists,
graphs.  Immutability: Which structures are immutable (e.g.,
Python tuples) vs mutable.  Syntax Differences: How to
declare, access, and modify common structures.

---

### 3. Algorithms & Language Support

 Standard Library Functions: Sorting, searching, string
manipulation, math functions.  Recursion Support: Tail
recursion optimization, recursion depth limits.  Iteration
Constructs: For loops, while loops, map/filter/reduce equivalents.
 Built-in Algorithmic Helpers: PriorityQueue, heapq, bisect,
itertools in Python, etc.

---

### 4. Performance & Complexity

 Time Complexity Notes: How language choice impacts runtime.
 Memory Usage: Differences in memory management, garbage
collection.  Multithreading/Concurrency Support: Threads,
async/await, coroutines.  Compiler/Interpreter Optimizations:
JIT (JavaScript/PyPy), compilation speed, runtime overhead.

---

### 5. Syntax Specifics for LeetCode

 Function Signature Conventions: How each language handles the
LeetCode-provided function template.  Class vs Static
Functions: Differences in implementing class methods for OOP-based
problems.  Input/Output Handling: Reading arrays, strings,
trees, linked lists, or custom objects.  Edge Case Handling:
Default values, null/nil handling, overflow handling.

---

### 6. Use Cases / Problem Type Suitability

 Commonly Solved Problems: Graphs, DP, strings, math, bit
manipulation.  Strengths: Fast prototyping, concise syntax,
fast execution, memory efficiency.  Weaknesses: Verbosity,
lack of library support, runtime penalties.

---

### 7. Language Idioms & Best Practices

 Python: List comprehensions, slicing, dict/Counter usage. 
Java: Streams, interfaces, OOP-heavy solutions.  C++:
STL, pointers/references, memory management.  JavaScript:
Functional programming patterns, object destructuring.  Go /
Rust: Safety, explicit memory management, concurrency patterns.

---

### 8. Error Handling & Debugging

 Exception Handling Syntax  Common Pitfalls: Index
errors, type errors, off-by-one errors.  Debugging Support:
Logging, print statements, debugger availability.

---

### 9. Community & Resources

 Documentation: Official docs, tutorials. 
LeetCode-Specific Tips: Language-specific LeetCode quirks,
popular solutions, templates.  Third-party Libraries: Only if
allowed in LeetCode.

---

### 10. Summary Table (Optional)

A quick-glance table comparing:

 Syntax brevity  Execution speed  Ease of debugging  Memory
usage  Suitability for common LeetCode problem types
